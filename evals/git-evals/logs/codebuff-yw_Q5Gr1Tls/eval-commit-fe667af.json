{"sha":"fe667af3a17f32624f5943804b77070986d3174f","spec":"Create a named constant for the default maximum agent steps value and ensure that the maximum agent steps limit is properly reset on every run.\n\nThe changes should include:\n\n1. **Extract magic number to constant**: Replace the hardcoded value `12` used as the default for `maxAgentSteps` with a named constant `DEFAULT_MAX_AGENT_STEPS` that can be imported and reused across modules.\n\n2. **Update schema to use constant**: Modify the Zod schema for `maxAgentSteps` to use the new constant instead of the hardcoded value.\n\n3. **Reset steps remaining on each run**: In the SDK client's `run` method, ensure that `sessionState.mainAgentState.stepsRemaining` is set to the `maxAgentSteps` value on every run call, effectively resetting the step counter.\n\n4. **Set default parameter value**: The `run` method's `maxAgentSteps` parameter should default to the `DEFAULT_MAX_AGENT_STEPS` constant when not provided.\n\n5. **Update changelog**: Document this as a bug fix that \"`maxAgentSteps` resets every run\" in the appropriate changelog section.\n\nThe behavior should ensure that regardless of whether a previous run state is provided, the agent step limit is always refreshed to the specified (or default) `maxAgentSteps` value at the start of each new run.","fileStates":[{"path":"common/src/json-config/constants.ts","preContent":"import { z } from 'zod/v4'\n\nexport const codebuffConfigFile = 'codebuff.json'\nexport const codebuffConfigFileBackup = 'codebuff.jsonc'\n\nexport const StartupProcessSchema = z\n  .object({\n    name: z\n      .string()\n      .min(1, 'Process name is required')\n      .describe(\n        'A user-friendly name for the process. Should be one word and unique.',\n      ),\n    command: z\n      .string()\n      .min(1, 'Command is required')\n      .describe('The actual shell command to execute.'),\n    cwd: z\n      .string()\n      .optional()\n      .describe('The working directory from which to run the command.'),\n    enabled: z\n      .boolean()\n      .optional()\n      .default(true)\n      .describe('Whether this process should be run'),\n    stdoutFile: z\n      .string()\n      .optional()\n      .describe(\n        \"Path to write the process's stdout. If not specified, stderr is not stored.\",\n      ),\n    stderrFile: z\n      .string()\n      .optional()\n      .describe(\n        \"Path to write the process's stderr. If not specified, stderr will be put into the stdoutFile.\",\n      ),\n  })\n  .describe('Defines a single startup process.')\n\nexport const FileChangeHook = z\n  .object({\n    name: z\n      .string()\n      .min(1, 'Hook name is required')\n      .describe(\n        'A user-friendly name for the hook. Should be one word and unique.',\n      ),\n    command: z\n      .string()\n      .min(1, 'Command is required')\n      .describe('The actual shell command to execute.'),\n    cwd: z\n      .string()\n      .optional()\n      .describe('The working directory from which to run the command.'),\n    filePattern: z.string().optional().describe('Glob pattern to match files.'),\n    enabled: z\n      .boolean()\n      .optional()\n      .default(true)\n      .describe('Whether this command should be run'),\n  })\n  .describe('Defines a single file change hook.')\n\nexport const CodebuffConfigSchema = z\n  .object({\n    description: z\n      .any()\n      .optional()\n      .describe('Does nothing. Put any thing you want here!'),\n    startupProcesses: z\n      .array(StartupProcessSchema)\n      .optional()\n      .describe('An array of startup processes.'),\n    fileChangeHooks: z\n      .array(FileChangeHook)\n      .optional()\n      .describe('An array of commands to run on file changes.'),\n    maxAgentSteps: z\n      .number()\n      .optional()\n      .default(12)\n      .describe(\n        'Maximum number of turns agent will take before being forced to end',\n      ),\n    baseAgent: z.string().optional().describe('Specify default base agent'),\n    spawnableAgents: z\n      .array(z.string())\n      .optional()\n      .describe('Specify complete list of spawnable agents for the base agent'),\n  })\n  .describe(\n    `Defines the overall Codebuff configuration file (e.g., ${codebuffConfigFile}). This schema defines the top-level structure of the configuration. This schema can be found at https://www.codebuff.com/config`,\n  )\n\n/**\n * TypeScript type representing a validated startup process object.\n * This type is inferred from the `StartupProcessSchema` and provides type safety\n * when working with startup process configurations in code.\n */\nexport type StartupProcess = z.infer<typeof StartupProcessSchema>\n\n/**\n * TypeScript type representing a validated Codebuff configuration object.\n * This type is inferred from the `CodebuffConfigSchema` and provides type safety\n * for the entire configuration structure.\n */\nexport type CodebuffConfig = z.infer<typeof CodebuffConfigSchema>\n","postContent":"import { z } from 'zod/v4'\n\nexport const codebuffConfigFile = 'codebuff.json'\nexport const codebuffConfigFileBackup = 'codebuff.jsonc'\n\nexport const StartupProcessSchema = z\n  .object({\n    name: z\n      .string()\n      .min(1, 'Process name is required')\n      .describe(\n        'A user-friendly name for the process. Should be one word and unique.',\n      ),\n    command: z\n      .string()\n      .min(1, 'Command is required')\n      .describe('The actual shell command to execute.'),\n    cwd: z\n      .string()\n      .optional()\n      .describe('The working directory from which to run the command.'),\n    enabled: z\n      .boolean()\n      .optional()\n      .default(true)\n      .describe('Whether this process should be run'),\n    stdoutFile: z\n      .string()\n      .optional()\n      .describe(\n        \"Path to write the process's stdout. If not specified, stderr is not stored.\",\n      ),\n    stderrFile: z\n      .string()\n      .optional()\n      .describe(\n        \"Path to write the process's stderr. If not specified, stderr will be put into the stdoutFile.\",\n      ),\n  })\n  .describe('Defines a single startup process.')\n\nexport const FileChangeHook = z\n  .object({\n    name: z\n      .string()\n      .min(1, 'Hook name is required')\n      .describe(\n        'A user-friendly name for the hook. Should be one word and unique.',\n      ),\n    command: z\n      .string()\n      .min(1, 'Command is required')\n      .describe('The actual shell command to execute.'),\n    cwd: z\n      .string()\n      .optional()\n      .describe('The working directory from which to run the command.'),\n    filePattern: z.string().optional().describe('Glob pattern to match files.'),\n    enabled: z\n      .boolean()\n      .optional()\n      .default(true)\n      .describe('Whether this command should be run'),\n  })\n  .describe('Defines a single file change hook.')\n\nexport const DEFAULT_MAX_AGENT_STEPS = 12\n\nexport const CodebuffConfigSchema = z\n  .object({\n    description: z\n      .any()\n      .optional()\n      .describe('Does nothing. Put any thing you want here!'),\n    startupProcesses: z\n      .array(StartupProcessSchema)\n      .optional()\n      .describe('An array of startup processes.'),\n    fileChangeHooks: z\n      .array(FileChangeHook)\n      .optional()\n      .describe('An array of commands to run on file changes.'),\n    maxAgentSteps: z\n      .number()\n      .optional()\n      .default(DEFAULT_MAX_AGENT_STEPS)\n      .describe(\n        'Maximum number of turns agent will take before being forced to end',\n      ),\n    baseAgent: z.string().optional().describe('Specify default base agent'),\n    spawnableAgents: z\n      .array(z.string())\n      .optional()\n      .describe('Specify complete list of spawnable agents for the base agent'),\n  })\n  .describe(\n    `Defines the overall Codebuff configuration file (e.g., ${codebuffConfigFile}). This schema defines the top-level structure of the configuration. This schema can be found at https://www.codebuff.com/config`,\n  )\n\n/**\n * TypeScript type representing a validated startup process object.\n * This type is inferred from the `StartupProcessSchema` and provides type safety\n * when working with startup process configurations in code.\n */\nexport type StartupProcess = z.infer<typeof StartupProcessSchema>\n\n/**\n * TypeScript type representing a validated Codebuff configuration object.\n * This type is inferred from the `CodebuffConfigSchema` and provides type safety\n * for the entire configuration structure.\n */\nexport type CodebuffConfig = z.infer<typeof CodebuffConfigSchema>\n"},{"path":"sdk/CHANGELOG.md","preContent":"# Changelog\n\nAll notable changes to the @codebuff/sdk package will be documented in this file.\n\n## [0.1.9] - 2025-08-13\n\n### Added\n\n- `closeConnection` method in `CodebuffClient`\n\n### Changed\n\n- Automatic parsing of `knowledgeFiles` if not provided\n\n## [0.1.8] - 2025-08-13\n\n### Added\n\n- `withAdditionalMessage` and `withMessageHistory` functions\n  - Add images, files, or other messages to a previous run\n  - Modify the history of any run\n- `initialSessionState` and `generateInitialRunState` functions\n  - Create a SessionState or RunState object from scratch\n\n### Removed\n\n- `getInitialSessionState` function\n\n## [0.1.7] - 2025-08-12\n\n### Updated types! AgentConfig has been renamed to AgentDefinition.\n\n## [0.1.5] - 2025-08-09\n\n### Added\n\n- Complete `CodebuffClient`\n- Better docs\n- New `run()` api\n\n## [0.0.1] - 2025-08-05\n\n### Added\n\n- Initial release of the Codebuff SDK\n- `CodebuffClient` class for interacting with Codebuff agents\n- `runNewChat` method for starting new chat sessions\n- TypeScript support with full type definitions\n- Support for all Codebuff agent types\n- Event streaming for real-time responses\n","postContent":"# Changelog\n\nAll notable changes to the @codebuff/sdk package will be documented in this file.\n\n## [0.1.9] - 2025-08-13\n\n### Added\n\n- `closeConnection` method in `CodebuffClient`\n\n### Changed\n\n- Automatic parsing of `knowledgeFiles` if not provided\n\n### Fixed\n\n- `maxAgentSteps` resets every run\n\n## [0.1.8] - 2025-08-13\n\n### Added\n\n- `withAdditionalMessage` and `withMessageHistory` functions\n  - Add images, files, or other messages to a previous run\n  - Modify the history of any run\n- `initialSessionState` and `generateInitialRunState` functions\n  - Create a SessionState or RunState object from scratch\n\n### Removed\n\n- `getInitialSessionState` function\n\n## [0.1.7] - 2025-08-12\n\n### Updated types! AgentConfig has been renamed to AgentDefinition.\n\n## [0.1.5] - 2025-08-09\n\n### Added\n\n- Complete `CodebuffClient`\n- Better docs\n- New `run()` api\n\n## [0.0.1] - 2025-08-05\n\n### Added\n\n- Initial release of the Codebuff SDK\n- `CodebuffClient` class for interacting with Codebuff agents\n- `runNewChat` method for starting new chat sessions\n- TypeScript support with full type definitions\n- Support for all Codebuff agent types\n- Event streaming for real-time responses\n"},{"path":"sdk/src/client.ts","preContent":"import { execFileSync } from 'child_process'\n\nimport { CODEBUFF_BINARY } from './constants'\nimport { initialSessionState, type RunState } from './run-state'\nimport { changeFile } from './tools/change-file'\nimport { getFiles } from './tools/read-files'\nimport { runTerminalCommand } from './tools/run-terminal-command'\nimport { WebSocketHandler } from './websocket-client'\nimport {\n  PromptResponseSchema,\n  type ServerAction,\n} from '../../common/src/actions'\nimport { API_KEY_ENV_VAR } from '../../common/src/constants'\n\nimport type { AgentDefinition } from '../../common/src/templates/initial-agents-dir/types/agent-definition'\nimport type { PrintModeEvent } from '../../common/src/types/print-mode'\n\ntype ClientToolName = 'write_file' | 'run_terminal_command'\n\nexport type CodebuffClientOptions = {\n  // Provide an API key or set the CODEBUFF_API_KEY environment variable.\n  apiKey?: string\n  cwd: string\n  onError: (error: { message: string }) => void\n  overrideTools?: Partial<\n    Record<\n      ClientToolName,\n      (\n        input: ServerAction<'tool-call-request'>['input'],\n      ) => Promise<{ toolResultMessage: string }>\n    > & {\n      // Include read_files separately, since it has a different signature.\n      read_files: (\n        filePath: string[],\n      ) => Promise<{ files: Record<string, string | null> }>\n    }\n  >\n}\n\nexport class CodebuffClient {\n  public cwd: string\n\n  private readonly websocketHandler: WebSocketHandler\n  private readonly overrideTools: NonNullable<\n    CodebuffClientOptions['overrideTools']\n  >\n  private readonly fingerprintId = `codebuff-sdk-${Math.random().toString(36).substring(2, 15)}`\n\n  private readonly promptIdToHandleEvent: Record<\n    string,\n    (event: PrintModeEvent) => void\n  > = {}\n  private readonly promptIdToResolveResponse: Record<\n    string,\n    { resolve: (response: any) => void; reject: (error: any) => void }\n  > = {}\n\n  constructor({ apiKey, cwd, onError, overrideTools }: CodebuffClientOptions) {\n    // TODO: download binary automatically\n    const isWindows = process.platform === 'win32'\n    if (\n      execFileSync(isWindows ? 'where' : 'which', [CODEBUFF_BINARY])\n        .toString()\n        .trim() === ''\n    ) {\n      throw new Error(\n        `Could not find ${CODEBUFF_BINARY} in PATH. Please run \"npm i -g codebuff\" to install codebuff.`,\n      )\n    }\n    const foundApiKey = apiKey ?? process.env[API_KEY_ENV_VAR]\n    if (!foundApiKey) {\n      throw new Error(\n        `Codebuff API key not found. Please provide an apiKey in the constructor of CodebuffClient or set the ${API_KEY_ENV_VAR} environment variable.`,\n      )\n    }\n\n    this.cwd = cwd\n    this.overrideTools = overrideTools ?? {}\n    this.websocketHandler = new WebSocketHandler({\n      apiKey: foundApiKey,\n      onWebsocketError: (error) => {\n        onError({ message: error.message })\n      },\n      onWebsocketReconnect: () => {},\n      onRequestReconnect: async () => {},\n      onResponseError: async (error) => {\n        onError({ message: error.message })\n      },\n      readFiles: this.readFiles.bind(this),\n      handleToolCall: this.handleToolCall.bind(this),\n      onCostResponse: async () => {},\n\n      onResponseChunk: async (action) => {\n        const { userInputId, chunk } = action\n        const handleEvent = this.promptIdToHandleEvent[userInputId]\n        if (handleEvent && typeof chunk === 'object') {\n          handleEvent(chunk)\n        }\n      },\n      onSubagentResponseChunk: async () => {},\n\n      onPromptResponse: this.handlePromptResponse.bind(this),\n    })\n  }\n\n  public closeConnection() {\n    this.websocketHandler.close()\n  }\n\n  /**\n   * Run a Codebuff agent with the specified options.\n   *\n   * @param agent - The agent to run. Use 'base' for the default agent, or specify a custom agent ID if you made your own agent config.\n   * @param prompt - The user prompt describing what you want the agent to do.\n   * @param params - (Optional) Additional parameters for the agent. Most agents don't use this, but some custom agents can take a JSON object as input in addition to the user prompt string.\n   * @param handleEvent - (Optional) Callback function that receives every event during execution (assistant messages, tool calls, etc.). This allows you to stream the agent's progress in real-time. We will likely add a token-by-token streaming callback in the future.\n   * @param previousRun - (Optional) JSON state returned from a previous run() call. Use this to continue a conversation or session with the agent, maintaining context from previous interactions.\n   * @param projectFiles - (Optional) All the files in your project as a plain JavaScript object. Keys should be the full path from your current directory to each file, and values should be the string contents of the file. Example: { \"src/index.ts\": \"console.log('hi')\" }. This helps Codebuff pick good source files for context.\n   * @param knowledgeFiles - (Optional) Knowledge files to inject into every run() call. Uses the same schema as projectFiles - keys are file paths and values are file contents. These files are added directly to the agent's context.\n   * @param agentDefinitions - (Optional) Array of custom agent definitions. Each object should satisfy the AgentDefinition type. You can input the agent's id field into the agent parameter to run that agent.\n   * @param maxAgentSteps - (Optional) Maximum number of steps the agent can take before stopping. Use this as a safety measure in case your agent starts going off the rails. A reasonable number is around 20.\n   *\n   * @returns A Promise that resolves to a RunState JSON object which you can pass to a subsequent run() call to continue the run.\n   */\n  public async run({\n    agent,\n    prompt,\n    params,\n    handleEvent,\n    previousRun,\n    projectFiles,\n    knowledgeFiles,\n    agentDefinitions,\n    maxAgentSteps,\n  }: {\n    agent: string\n    prompt: string\n    params?: Record<string, any>\n    handleEvent?: (event: PrintModeEvent) => void\n    previousRun?: RunState\n    projectFiles?: Record<string, string>\n    knowledgeFiles?: Record<string, string>\n    agentDefinitions?: AgentDefinition[]\n    maxAgentSteps?: number\n  }): Promise<RunState> {\n    await this.websocketHandler.connect()\n\n    const promptId = Math.random().toString(36).substring(2, 15)\n    const sessionState =\n      previousRun?.sessionState ??\n      initialSessionState(this.cwd, {\n        knowledgeFiles,\n        agentDefinitions,\n        projectFiles,\n        maxAgentSteps,\n      })\n    const toolResults = previousRun?.toolResults ?? []\n    if (handleEvent) {\n      this.promptIdToHandleEvent[promptId] = handleEvent\n    }\n    this.websocketHandler.sendInput({\n      promptId,\n      prompt,\n      promptParams: params,\n      fingerprintId: this.fingerprintId,\n      costMode: 'normal',\n      sessionState,\n      toolResults,\n      agentId: agent,\n    })\n\n    return new Promise<RunState>((resolve, reject) => {\n      this.promptIdToResolveResponse[promptId] = { resolve, reject }\n    })\n  }\n\n  private async handlePromptResponse(action: ServerAction<'prompt-response'>) {\n    const promiseActions =\n      this.promptIdToResolveResponse[action?.promptId ?? '']\n\n    const parsedAction = PromptResponseSchema.safeParse(action)\n    if (!parsedAction.success) {\n      const message = [\n        'Received invalid prompt response from server:',\n        JSON.stringify(parsedAction.error.issues),\n        'If this issues persists, please contact support@codebuff.com',\n      ].join('\\n')\n      if (promiseActions) {\n        promiseActions.reject(new Error(message))\n      }\n      return\n    }\n\n    if (promiseActions) {\n      const { sessionState, toolResults } = parsedAction.data\n      const state: RunState = {\n        sessionState,\n        toolResults,\n      }\n      promiseActions.resolve(state)\n\n      delete this.promptIdToResolveResponse[action.promptId]\n      delete this.promptIdToHandleEvent[action.promptId]\n    }\n  }\n\n  private async readFiles(filePath: string[]) {\n    const override = this.overrideTools.read_files\n    if (override) {\n      const overrideResult = await override(filePath)\n      return overrideResult.files\n    }\n    return getFiles(filePath, this.cwd)\n  }\n\n  private async handleToolCall(\n    action: ServerAction<'tool-call-request'>,\n  ): ReturnType<WebSocketHandler['handleToolCall']> {\n    const toolName = action.toolName\n    const input = action.input\n    let result: string\n    try {\n      let override = this.overrideTools[toolName as ClientToolName]\n      if (!override && toolName === 'str_replace') {\n        // Note: write_file and str_replace have the same implementation, so reuse their write_file override.\n        override = this.overrideTools['write_file']\n      }\n      if (override) {\n        const overrideResult = await override(input)\n        result = overrideResult.toolResultMessage\n      } else if (toolName === 'end_turn') {\n        result = ''\n      } else if (toolName === 'write_file' || toolName === 'str_replace') {\n        const r = changeFile(input, this.cwd)\n        result = r.toolResultMessage\n      } else if (toolName === 'run_terminal_command') {\n        const r = await runTerminalCommand({\n          ...input,\n          cwd: input.cwd ?? this.cwd,\n        } as Parameters<typeof runTerminalCommand>[0])\n        result = r.output\n      } else {\n        throw new Error(\n          `Tool not implemented in SDK. Please provide an override or modify your agent to not use this tool: ${toolName}`,\n        )\n      }\n    } catch (error) {\n      return {\n        success: false,\n        output: {\n          type: 'text',\n          value:\n            error &&\n            typeof error === 'object' &&\n            'message' in error &&\n            typeof error.message === 'string'\n              ? error.message\n              : typeof error === 'string'\n                ? error\n                : 'Unknown error',\n        },\n      }\n    }\n    return {\n      success: true,\n      output: {\n        type: 'text',\n        value: result,\n      },\n    }\n  }\n}\n","postContent":"import { execFileSync } from 'child_process'\n\nimport { CODEBUFF_BINARY } from './constants'\nimport { initialSessionState, type RunState } from './run-state'\nimport { changeFile } from './tools/change-file'\nimport { getFiles } from './tools/read-files'\nimport { runTerminalCommand } from './tools/run-terminal-command'\nimport { WebSocketHandler } from './websocket-client'\nimport {\n  PromptResponseSchema,\n  type ServerAction,\n} from '../../common/src/actions'\nimport { API_KEY_ENV_VAR } from '../../common/src/constants'\nimport { DEFAULT_MAX_AGENT_STEPS } from '../../common/src/json-config/constants'\n\nimport type { AgentDefinition } from '../../common/src/templates/initial-agents-dir/types/agent-definition'\nimport type { PrintModeEvent } from '../../common/src/types/print-mode'\n\ntype ClientToolName = 'write_file' | 'run_terminal_command'\n\nexport type CodebuffClientOptions = {\n  // Provide an API key or set the CODEBUFF_API_KEY environment variable.\n  apiKey?: string\n  cwd: string\n  onError: (error: { message: string }) => void\n  overrideTools?: Partial<\n    Record<\n      ClientToolName,\n      (\n        input: ServerAction<'tool-call-request'>['input'],\n      ) => Promise<{ toolResultMessage: string }>\n    > & {\n      // Include read_files separately, since it has a different signature.\n      read_files: (\n        filePath: string[],\n      ) => Promise<{ files: Record<string, string | null> }>\n    }\n  >\n}\n\nexport class CodebuffClient {\n  public cwd: string\n\n  private readonly websocketHandler: WebSocketHandler\n  private readonly overrideTools: NonNullable<\n    CodebuffClientOptions['overrideTools']\n  >\n  private readonly fingerprintId = `codebuff-sdk-${Math.random().toString(36).substring(2, 15)}`\n\n  private readonly promptIdToHandleEvent: Record<\n    string,\n    (event: PrintModeEvent) => void\n  > = {}\n  private readonly promptIdToResolveResponse: Record<\n    string,\n    { resolve: (response: any) => void; reject: (error: any) => void }\n  > = {}\n\n  constructor({ apiKey, cwd, onError, overrideTools }: CodebuffClientOptions) {\n    // TODO: download binary automatically\n    const isWindows = process.platform === 'win32'\n    if (\n      execFileSync(isWindows ? 'where' : 'which', [CODEBUFF_BINARY])\n        .toString()\n        .trim() === ''\n    ) {\n      throw new Error(\n        `Could not find ${CODEBUFF_BINARY} in PATH. Please run \"npm i -g codebuff\" to install codebuff.`,\n      )\n    }\n    const foundApiKey = apiKey ?? process.env[API_KEY_ENV_VAR]\n    if (!foundApiKey) {\n      throw new Error(\n        `Codebuff API key not found. Please provide an apiKey in the constructor of CodebuffClient or set the ${API_KEY_ENV_VAR} environment variable.`,\n      )\n    }\n\n    this.cwd = cwd\n    this.overrideTools = overrideTools ?? {}\n    this.websocketHandler = new WebSocketHandler({\n      apiKey: foundApiKey,\n      onWebsocketError: (error) => {\n        onError({ message: error.message })\n      },\n      onWebsocketReconnect: () => {},\n      onRequestReconnect: async () => {},\n      onResponseError: async (error) => {\n        onError({ message: error.message })\n      },\n      readFiles: this.readFiles.bind(this),\n      handleToolCall: this.handleToolCall.bind(this),\n      onCostResponse: async () => {},\n\n      onResponseChunk: async (action) => {\n        const { userInputId, chunk } = action\n        const handleEvent = this.promptIdToHandleEvent[userInputId]\n        if (handleEvent && typeof chunk === 'object') {\n          handleEvent(chunk)\n        }\n      },\n      onSubagentResponseChunk: async () => {},\n\n      onPromptResponse: this.handlePromptResponse.bind(this),\n    })\n  }\n\n  public closeConnection() {\n    this.websocketHandler.close()\n  }\n\n  /**\n   * Run a Codebuff agent with the specified options.\n   *\n   * @param agent - The agent to run. Use 'base' for the default agent, or specify a custom agent ID if you made your own agent config.\n   * @param prompt - The user prompt describing what you want the agent to do.\n   * @param params - (Optional) Additional parameters for the agent. Most agents don't use this, but some custom agents can take a JSON object as input in addition to the user prompt string.\n   * @param handleEvent - (Optional) Callback function that receives every event during execution (assistant messages, tool calls, etc.). This allows you to stream the agent's progress in real-time. We will likely add a token-by-token streaming callback in the future.\n   * @param previousRun - (Optional) JSON state returned from a previous run() call. Use this to continue a conversation or session with the agent, maintaining context from previous interactions.\n   * @param projectFiles - (Optional) All the files in your project as a plain JavaScript object. Keys should be the full path from your current directory to each file, and values should be the string contents of the file. Example: { \"src/index.ts\": \"console.log('hi')\" }. This helps Codebuff pick good source files for context.\n   * @param knowledgeFiles - (Optional) Knowledge files to inject into every run() call. Uses the same schema as projectFiles - keys are file paths and values are file contents. These files are added directly to the agent's context.\n   * @param agentDefinitions - (Optional) Array of custom agent definitions. Each object should satisfy the AgentDefinition type. You can input the agent's id field into the agent parameter to run that agent.\n   * @param maxAgentSteps - (Optional) Maximum number of steps the agent can take before stopping. Use this as a safety measure in case your agent starts going off the rails. A reasonable number is around 20.\n   *\n   * @returns A Promise that resolves to a RunState JSON object which you can pass to a subsequent run() call to continue the run.\n   */\n  public async run({\n    agent,\n    prompt,\n    params,\n    handleEvent,\n    previousRun,\n    projectFiles,\n    knowledgeFiles,\n    agentDefinitions,\n    maxAgentSteps = DEFAULT_MAX_AGENT_STEPS,\n  }: {\n    agent: string\n    prompt: string\n    params?: Record<string, any>\n    handleEvent?: (event: PrintModeEvent) => void\n    previousRun?: RunState\n    projectFiles?: Record<string, string>\n    knowledgeFiles?: Record<string, string>\n    agentDefinitions?: AgentDefinition[]\n    maxAgentSteps?: number\n  }): Promise<RunState> {\n    await this.websocketHandler.connect()\n\n    const promptId = Math.random().toString(36).substring(2, 15)\n    const sessionState =\n      previousRun?.sessionState ??\n      initialSessionState(this.cwd, {\n        knowledgeFiles,\n        agentDefinitions,\n        projectFiles,\n        maxAgentSteps,\n      })\n    sessionState.mainAgentState.stepsRemaining = maxAgentSteps\n    const toolResults = previousRun?.toolResults ?? []\n    if (handleEvent) {\n      this.promptIdToHandleEvent[promptId] = handleEvent\n    }\n    this.websocketHandler.sendInput({\n      promptId,\n      prompt,\n      promptParams: params,\n      fingerprintId: this.fingerprintId,\n      costMode: 'normal',\n      sessionState,\n      toolResults,\n      agentId: agent,\n    })\n\n    return new Promise<RunState>((resolve, reject) => {\n      this.promptIdToResolveResponse[promptId] = { resolve, reject }\n    })\n  }\n\n  private async handlePromptResponse(action: ServerAction<'prompt-response'>) {\n    const promiseActions =\n      this.promptIdToResolveResponse[action?.promptId ?? '']\n\n    const parsedAction = PromptResponseSchema.safeParse(action)\n    if (!parsedAction.success) {\n      const message = [\n        'Received invalid prompt response from server:',\n        JSON.stringify(parsedAction.error.issues),\n        'If this issues persists, please contact support@codebuff.com',\n      ].join('\\n')\n      if (promiseActions) {\n        promiseActions.reject(new Error(message))\n      }\n      return\n    }\n\n    if (promiseActions) {\n      const { sessionState, toolResults } = parsedAction.data\n      const state: RunState = {\n        sessionState,\n        toolResults,\n      }\n      promiseActions.resolve(state)\n\n      delete this.promptIdToResolveResponse[action.promptId]\n      delete this.promptIdToHandleEvent[action.promptId]\n    }\n  }\n\n  private async readFiles(filePath: string[]) {\n    const override = this.overrideTools.read_files\n    if (override) {\n      const overrideResult = await override(filePath)\n      return overrideResult.files\n    }\n    return getFiles(filePath, this.cwd)\n  }\n\n  private async handleToolCall(\n    action: ServerAction<'tool-call-request'>,\n  ): ReturnType<WebSocketHandler['handleToolCall']> {\n    const toolName = action.toolName\n    const input = action.input\n    let result: string\n    try {\n      let override = this.overrideTools[toolName as ClientToolName]\n      if (!override && toolName === 'str_replace') {\n        // Note: write_file and str_replace have the same implementation, so reuse their write_file override.\n        override = this.overrideTools['write_file']\n      }\n      if (override) {\n        const overrideResult = await override(input)\n        result = overrideResult.toolResultMessage\n      } else if (toolName === 'end_turn') {\n        result = ''\n      } else if (toolName === 'write_file' || toolName === 'str_replace') {\n        const r = changeFile(input, this.cwd)\n        result = r.toolResultMessage\n      } else if (toolName === 'run_terminal_command') {\n        const r = await runTerminalCommand({\n          ...input,\n          cwd: input.cwd ?? this.cwd,\n        } as Parameters<typeof runTerminalCommand>[0])\n        result = r.output\n      } else {\n        throw new Error(\n          `Tool not implemented in SDK. Please provide an override or modify your agent to not use this tool: ${toolName}`,\n        )\n      }\n    } catch (error) {\n      return {\n        success: false,\n        output: {\n          type: 'text',\n          value:\n            error &&\n            typeof error === 'object' &&\n            'message' in error &&\n            typeof error.message === 'string'\n              ? error.message\n              : typeof error === 'string'\n                ? error\n                : 'Unknown error',\n        },\n      }\n    }\n    return {\n      success: true,\n      output: {\n        type: 'text',\n        value: result,\n      },\n    }\n  }\n}\n"}]}